#include <Carbon/Carbon.h>
#include <unistd.h>
#include <ApplicationServices/ApplicationServices.h>

extern OSStatus GetProcessPID(const ProcessSerialNumber *psn, pid_t *pid);
extern void _SLPSGetFrontProcess(ProcessSerialNumber* psn);
extern int SLSMainConnectionID();

void ax_init() {
    const void *keys[] = { kAXTrustedCheckOptionPrompt };
    const void *values[] = { kCFBooleanTrue };

    CFDictionaryRef options = CFDictionaryCreate(kCFAllocatorDefault,
                                                 keys,
                                                 values,
                                                 sizeof(keys) / sizeof(*keys),
                                                 &kCFCopyStringDictionaryKeyCallBacks,
                                                 &kCFTypeDictionaryValueCallBacks);

    bool trusted = AXIsProcessTrustedWithOptions(options);
    CFRelease(options);

    if (!trusted) {
        fprintf(stderr, "Error: Accessibility permissions not granted. Please enable them in System Settings > Privacy & Security > Accessibility.\n");
        exit(1);
    }
}

void ax_perform_click(AXUIElementRef element) {
    if (!element) return;
    AXError error = AXUIElementPerformAction(element, kAXPressAction);
    if (error != kAXErrorSuccess) {
        fprintf(stderr, "Error performing press action: %d\n", error);
    }
}

void ax_send_escape_key() {
    CGEventRef keyDown = CGEventCreateKeyboardEvent(NULL, kVK_Escape, true);
    CGEventRef keyUp = CGEventCreateKeyboardEvent(NULL, kVK_Escape, false);

    if (keyDown && keyUp) {
        CGEventPost(kCGHIDEventTap, keyDown);
        CGEventPost(kCGHIDEventTap, keyUp);
    } else {
        fprintf(stderr, "Error creating keyboard events for Escape key.\n");
    }

    if (keyDown) CFRelease(keyDown);
    if (keyUp) CFRelease(keyUp);

    usleep(50000);
}

CFStringRef ax_get_title(AXUIElementRef element) {
    CFTypeRef titleRef = NULL;
    AXError error = AXUIElementCopyAttributeValue(element, kAXTitleAttribute, &titleRef);
    if (error != kAXErrorSuccess) {
        return NULL;
    }
    return (CFStringRef)titleRef;
}

void ax_select_menu_option(AXUIElementRef app, int id) {
    AXUIElementRef menubarsRef = NULL;
    CFArrayRef childrenRef = NULL;

    AXError error = AXUIElementCopyAttributeValue(app, kAXMenuBarAttribute, (CFTypeRef*)&menubarsRef);
    if (error == kAXErrorSuccess && menubarsRef) {
        error = AXUIElementCopyAttributeValue(menubarsRef, kAXVisibleChildrenAttribute, (CFTypeRef*)&childrenRef);
        if (error == kAXErrorSuccess && childrenRef) {
            uint32_t count = CFArrayGetCount(childrenRef);
            if (id >= 0 && id < count) {
                AXUIElementRef item = (AXUIElementRef)CFArrayGetValueAtIndex(childrenRef, id);
                ax_perform_click(item);
                // Removed ax_send_escape_key() here, as it was closing the menu immediately
            } else {
                fprintf(stderr, "Error: Menu option ID %d out of bounds (0-%u).\n", id, count - 1);
            }
            CFRelease(childrenRef);
        } else if (error != kAXErrorSuccess) {
            fprintf(stderr, "Error getting menu bar children: %d\n", error);
        }
        CFRelease(menubarsRef);
    } else if (error != kAXErrorSuccess) {
        fprintf(stderr, "Error getting menu bar: %d\n", error);
    }
}

void ax_print_menu_options(AXUIElementRef app) {
    AXUIElementRef menubarsRef = NULL;
    CFArrayRef childrenRef = NULL;

    AXError error = AXUIElementCopyAttributeValue(app, kAXMenuBarAttribute, (CFTypeRef*)&menubarsRef);
    if (error == kAXErrorSuccess && menubarsRef) {
        error = AXUIElementCopyAttributeValue(menubarsRef, kAXVisibleChildrenAttribute, (CFTypeRef*)&childrenRef);
        if (error == kAXErrorSuccess && childrenRef) {
            uint32_t count = CFArrayGetCount(childrenRef);

            for (int i = 0; i < count; i++) {
                AXUIElementRef item = (AXUIElementRef)CFArrayGetValueAtIndex(childrenRef, i);
                CFStringRef title = ax_get_title(item);

                if (title) {
                    CFIndex length = CFStringGetLength(title);
                    CFIndex max_buf_len = CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;
                    char *buffer = (char *)malloc(max_buf_len);
                    if (buffer && CFStringGetCString(title, buffer, max_buf_len, kCFStringEncodingUTF8)) {
                        printf("%d: %s\n", i, buffer);
                    }
                    free(buffer);
                    CFRelease(title);
                }
            }
            CFRelease(childrenRef);
        } else if (error != kAXErrorSuccess) {
            fprintf(stderr, "Error getting menu bar children: %d\n", error);
        }
        CFRelease(menubarsRef);
    } else if (error != kAXErrorSuccess) {
        fprintf(stderr, "Error getting menu bar: %d\n", error);
    }
}

AXUIElementRef ax_get_extra_menu_item(char* alias) {
    pid_t pid = 0;
    CGRect bounds = CGRectNull;
    CFArrayRef windowList = CGWindowListCopyWindowInfo(kCGWindowListOptionAll, kCGNullWindowID);

    char ownerBuffer[256], nameBuffer[256], combinedBuffer[512];

    if (!windowList) {
        fprintf(stderr, "Error: Could not get window list.\n");
        return NULL;
    }

    int windowCount = CFArrayGetCount(windowList);
    for (int i = 0; i < windowCount; ++i) {
        CFDictionaryRef dict = (CFDictionaryRef)CFArrayGetValueAtIndex(windowList, i);
        if (!dict) continue;

        CFStringRef ownerRef = (CFStringRef)CFDictionaryGetValue(dict, kCGWindowOwnerName);
        CFNumberRef ownerPidRef = (CFNumberRef)CFDictionaryGetValue(dict, kCGWindowOwnerPID);
        CFStringRef nameRef = (CFStringRef)CFDictionaryGetValue(dict, kCGWindowName);
        CFNumberRef layerRef = (CFNumberRef)CFDictionaryGetValue(dict, kCGWindowLayer);
        CFDictionaryRef boundsRef = (CFDictionaryRef)CFDictionaryGetValue(dict, kCGWindowBounds);

        if (!nameRef || !ownerRef || !ownerPidRef || !layerRef || !boundsRef) continue;

        long long int layer = 0;
        CFNumberGetValue(layerRef, kCFNumberLongLongType, &layer);
        pid_t currentPid = 0;
        CFNumberGetValue(ownerPidRef, kCFNumberIntType, &currentPid);

        if (layer != 0x19) continue;

        if (!CGRectMakeWithDictionaryRepresentation(boundsRef, &bounds)) continue;

        if (!CFStringGetCString(ownerRef, ownerBuffer, sizeof(ownerBuffer), kCFStringEncodingUTF8) ||
            !CFStringGetCString(nameRef, nameBuffer, sizeof(nameBuffer), kCFStringEncodingUTF8)) {
            fprintf(stderr, "Error converting strings for window info.\n");
            continue;
        }

        snprintf(combinedBuffer, sizeof(combinedBuffer), "%s,%s", ownerBuffer, nameBuffer);

        if (strcmp(combinedBuffer, alias) == 0) {
            pid = currentPid;
            break;
        }
    }
    CFRelease(windowList);

    if (!pid) {
        fprintf(stderr, "Error: Could not find menu extra with alias '%s'.\n", alias);
        return NULL;
    }

    AXUIElementRef app = AXUIElementCreateApplication(pid);
    if (!app) {
        fprintf(stderr, "Error: Could not create AXUIElement for PID %d.\n", pid);
        return NULL;
    }

    AXUIElementRef result = NULL;
    CFTypeRef extrasRef = NULL;
    CFArrayRef childrenRef = NULL;

    AXError error = AXUIElementCopyAttributeValue(app, kAXExtrasMenuBarAttribute, &extrasRef);
    if (error == kAXErrorSuccess && extrasRef) {
        error = AXUIElementCopyAttributeValue(extrasRef, kAXVisibleChildrenAttribute, (CFTypeRef*)&childrenRef);
        if (error == kAXErrorSuccess && childrenRef) {
            uint32_t count = CFArrayGetCount(childrenRef);
            for (uint32_t i = 0; i < count; i++) {
                AXUIElementRef item = (AXUIElementRef)CFArrayGetValueAtIndex(childrenRef, i);
                CFTypeRef positionRef = NULL, sizeRef = NULL;

                AXUIElementCopyAttributeValue(item, kAXPositionAttribute, &positionRef);
                AXUIElementCopyAttributeValue(item, kAXSizeAttribute, &sizeRef);

                if (!positionRef || !sizeRef) {
                    if (positionRef) CFRelease(positionRef);
                    if (sizeRef) CFRelease(sizeRef);
                    continue;
                }

                CGPoint position = CGPointZero;
                AXValueGetValue(positionRef, kAXValueCGPointType, &position);
                CFRelease(positionRef);
                CFRelease(sizeRef);

                if (fabs(position.x - bounds.origin.x) <= 10) {
                    result = item;
                    break;
                }
            }
            CFRelease(childrenRef);
        } else if (error != kAXErrorSuccess) {
            fprintf(stderr, "Error getting menu extra children: %d\n", error);
        }
        CFRelease(extrasRef);
    } else if (error != kAXErrorSuccess) {
        fprintf(stderr, "Error getting menu extras bar: %d\n", error);
    }

    CFRelease(app);
    return result;
}

void ax_select_menu_extra(char* alias) {
    AXUIElementRef item = ax_get_extra_menu_item(alias);
    if (!item) return;

    ax_perform_click(item);

    CFRelease(item);
}

AXUIElementRef ax_get_front_app() {
    ProcessSerialNumber psn;
    _SLPSGetFrontProcess(&psn);

    pid_t pid;
    if (GetProcessPID(&psn, &pid) != noErr) {
        fprintf(stderr, "Error: Could not get PID for frontmost process.\n");
        return NULL;
    }
    return AXUIElementCreateApplication(pid);
}

int main (int argc, char **argv) {
    if (argc == 1) {
        printf("Usage: %s [-l | -s id/alias ]\n", argv[0]);
        exit(0);
    }

    ax_init();

    AXUIElementRef app = NULL;
    int result = 0;

    if (strcmp(argv[1], "-l") == 0) {
        app = ax_get_front_app();
        if (!app) {
            fprintf(stderr, "Error: Could not get frontmost application.\n");
            result = 1;
        } else {
            ax_print_menu_options(app);
        }
    } else if (argc == 3 && strcmp(argv[1], "-s") == 0) {
        int id = 0;
        if (sscanf(argv[2], "%d", &id) == 1) {
            app = ax_get_front_app();
            if (!app) {
                fprintf(stderr, "Error: Could not get frontmost application.\n");
                result = 1;
            } else {
                ax_select_menu_option(app, id);
            }
        } else {
            ax_select_menu_extra(argv[2]);
        }
    } else {
        fprintf(stderr, "Error: Invalid arguments.\n");
        printf("Usage: %s [-l | -s id/alias ]\n", argv[0]);
        result = 1;
    }

    if (app) CFRelease(app);
    return result;
}

